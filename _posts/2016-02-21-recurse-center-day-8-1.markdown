---
published: true
title: Recurse Center, Day 8.1
layout: post
---
Today was neither overwhelmingly productive nor overwhelmingly unproductive. 

I made a few more stabs at understanding this stuff in Erik Meijer's MOOC. As far as I can tell, this chapter is his attempt to introduce monads by demonstrating [parser combinators](https://en.wikipedia.org/wiki/Parser_combinator), which in principle I guess is cool, except with all the stuff about parsers he's assuming some background knowledge of parsing/formal languages/context-free grammars. So trying to learn 1) Haskell, 2) Haskell's monad system, and 3) fancy parsing, is a bit too much at once. I don't know. Maybe I should just skip ahead. I'm not sure it's actually necessary for the rest of the course (which I'm about halfway through). But parsing is something I *actually want to learn about*! Also, it's through parsing that the course seems to be explaining monads, so, maybe it is necessary. 

[Evan Czaplicki](http://evan.czaplicki.us/) is in residence this week at RC. He's the designer of [Elm](https://en.wikipedia.org/wiki/Elm_(programming_language)), a new-ish trendy front-end functional programming language. He spoke (or, really, live-coded Elm) at RC's Monday night talk series, which was unusually well-attended tonight. And this afternoon he led an informal seminar on programming language design and the motivations behind his design choices in Elm. The conversation was really fun: he spoke a lot about humility (my word). E.g., lots of people look at C++ today and think, "This is awful! Why would you ever do it in this way?" That's true from today's perspective. But 30 years ago, when C++ was created, a lot of those decisions were really good ones, or at least made sense in the intellectual/computational context of the 1980s. (For example: people were transferring compilers (and everything else) *on floppy disks*.) Ideas have a right time. Most ideas aren't separable from their chronological contexts.

The other thing that Evan spoke about was the importance of NOT allowing people to do things. If you add lots of features to your language, then people will end up writing, e.g., Python in Elm syntax. But that defeats the purpose of a new language! Languages should be encouraging/rewarding certain behaviors, and discouraging (or flat-out denying) other behaviors. This dovetails with a lot of my more general philosophical beliefs (freedom isn't the absence of restrictions, but something that comes THROUGH restrictions.) So it was cool to see it applied to this domain. And I was impressed with the fortitude Evan showed. He didn't quite say this, but I got the impression that a big part of his job as the creator/maintainer is to say "no" ("no, we can't have this feature). In fact, apparently he's *taken out* several features from the language (this came up again at his talk, in the Q&A), and said he'll probably take out more as he figures out how to simplify it.

And, I guess a lot of the reason for that (by "I guess" I mean "he said exactly as much") is that, in his description, the idea of a general-purpose programming language is silly. Programming languages are tools, and if we try make a tool that's SO general and SO abstract as to be able to do EVERYTHING, then there won't be any ONE thing that it's PARTICULARLY excellent at. In Elm's case, Elm is for front-end web development, and so that's how he makes design decisions: will including (or removing) feature X from Elm make it a more excellent front-end language?

Speaking of which: one thing that stuck out in Evan's diction is that he kept using the word "excellent" (how to make things "more excellent," etc.). I like that. When we were reading the Nicomachean Ethics, Jamie Redfield encouraged us to substitute "excellence" (or just "quality X") for "virtue", which I guess is a common/controversial modern way to read Aristotle. I was reminded of that. His frequent use of "excellent" keeps the end goals in mind (to create a programming language that's excellent at doing certain things).

Also, I had to write down this quip he made about Haskell: "It's like someone took 30 years of really excellent [programming language] research and turned it into a game I can play." (I guess Evan's background is Haskell and FP: the Elm compiler is written in Haskell.)