---
published: true
title: Recurse Center, Day Weekend!
layout: post
---
Friday isn't an official RC day (although I did come in), and Monday isn't one either (because it's MLK day), but we have access to the space 24/7, and I've been here most of the day yesterday and today. 

What have I accomplished? Basically nothing. As a sort of extension/generalization of the stuff I started writing when I was making my Game of Life implementation, I spent most of Friday starting to write an in-browser implementation of Tetris (although I imagined it being slightly cooler: having blocks fly in from all four sides. So like two-dimensional Tetris). On Friday I got as far as having blocks fly around the screen. Yet today and yesterday I mostly just screwed around, because basically I'm at the point where I'd have to figure out how to figure out when a block has fallen into place, which is the sort of thing that's conceptually totally straightforward (look! that block is on top of the other ones!), and yet without any specialized libraries I have to write the whole thing by hand... which I sort of started doing, and I realized what a ridiculous composition of traversing traversals of array traversals it would be, which would be a mess, and probably my intuitive algorithms would be really inefficient, etc., etc., etc... that probably makes no sense to the reader; the point is that it's something that's both tedious and (while not conceptually all THAT difficult), not 100% clear in my mind how to do. 

Well, but I could figure it out. It'd just be work. The problem isn't that it's tedious. It's that it's tedious, *and I don't really care about the end result*. Two-dimensional Tetris is MILDLY interesting. But that's about it. I'm not particularly passionate about it. (I don't know why I would be.) When it comes to writing code, I find that I need really compelling broader goals to do it. The act of writing code is more-or-less enjoyable, but not SO enjoyable that writing it without any good goal (Tetris! why not!) is that appealing. Gah. I'm not even writing ENGLISH very well right now. (I guess I'm pretty good at writing English without having a goal!)

Anyway. Honestly, even if it wasn't that intellectually challenging (or maybe BECAUSE of that), the two six-hour stretches that I spent writing my Life implementation (on Wednesday) and the beginnings of Tetris (on Friday) have been the most enjoyable of my time at RC. I was able to be totally absorbed in the work.

I should probably think about goals for next week ("stop squandering every good opportunity that comes your way"). But, actually, here, no, I'll say something positive and exciting: so, yesterday, [Michael Nielsen](http://michaelnielsen.org/) wandered into the room I was working in, and (thanks to the presence of D.) got to talking about what he's been working on. So he's [RC's resident research fellow](https://www.recurse.com/blog/83-michael-nielsen-joins-the-recurse-center-to-help-build-a-research-lab), having abandoned a successful career in quantum computing a few years back to work on radically different stuff. Right now he's working on new ways of doing mathematics in/with computers, a la [Bret Victor's Kill Math project](http://worrydream.com/KillMath/) (actually, I think before he was at RC he was working with Bret or something). Anyway, right now (and I guess I can say this?) he's working on an interactive medium for doing linear algebra. I.e., not just COMPUTING linear algebra problems, and not just Mathematica-esque symbolic manipulation, but something that gets closer linear algebra's geometric heart. D. said he had seen a demo, and it was really amazing.

Anyway, Michael told us what he's been thinking about this week, namely, how do you represent a proof by contradiction on a computer? On paper, you can just write it out. You can make all sorts of crazy assumptions, and work them out, and see where they do, and see if they create contradictions. But on a computer you can't do that. You don't have a piece of paper with equations on it. You just have your state, and all it says is "Undefined". The computer has already realized that your assumptions are erroneous, as soon as you've made them. So how do you deal with that? 

He made the analogy to type systems in programming (which is certainly something I've been grappling a lot with!). Some languages are weakly typed and let you potentially make lots of type errors; others are strongly typed and prevent that (but also make it a lot harder to experiment and fool around). People get very passionate about supporting one extreme or the other. But most of the time the best place to be is somewhere in the middle. So that's what he's trying to work into his doing-linear-algebra medium. 

I'm so jealous, and so enthralled. It all sounds so awesome. I also really like the analogy, since it ties together two really different (and non-superficial) concepts. (On a deeply uncomfortable personal note, he has [a blog post](https://mnielsen.github.io/notes/tfoc/index.html) in which he writes about his various inspirations for similar types of  "new cognitive tools", and lists R.'s projects near the top.) 

C. would have been 29 today. I unexpectedly stumbled across the statue of Balto in Central Park and burst out into tears. S. emailed to say that she went to a party in an abandoned underground reservoir and then biked home in the snow. I still don't have a place to stay and I'm terrified that M. is furious with me for still being on his futon.